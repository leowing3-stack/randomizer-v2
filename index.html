<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>SocialBurst — 16-bit Game Boy Explorer</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<!-- Brand fonts from your repo -->
<style>
  @font-face {
    font-family: "BrotherBold";
    src: url("./SocialBurstRandomizer/fonts/BROTHER-Bold.ttf") format("truetype");
    font-weight: 700; font-style: normal; font-display: swap;
  }
  @font-face {
    font-family: "Lexend";
    src: url("./SocialBurstRandomizer/fonts/Lexend-VariableFont_wght.ttf") format("truetype");
    font-weight: 100 900; font-style: normal; font-display: swap;
  }
  @font-face {
    font-family: "MadeTommyBold";
    src: url("./SocialBurstRandomizer/fonts/MADE TOMMY Bold_PERSONAL USE.otf") format("opentype");
    font-weight: 700; font-style: normal; font-display: swap;
  }

  :root{
    --purple:#8338EC;
    --yellow:#FFEC1F;
    --white:#ffffff;
    --black:#000000;

    --shell:#6a2ee0;
    --shell-dark:#4f22a8;
    --shell-light:#8d5bf0;

    --shadow:0 18px 40px rgba(0,0,0,.28);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 50% -20%, #eee, #d8d8ff 60%, #c7c7ff 100%);
    color:#0f0f12;
    font-family: Lexend, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
    overflow:hidden;
  }

  header.topbar{
    position:fixed; top:8px; left:8px; right:8px; z-index:50;
    display:flex; align-items:center; gap:10px;
    background:rgba(255,255,255,0.7); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:6px 10px;
  }
  .brand{display:flex; align-items:center; gap:8px}
  .brand img{width:32px; height:32px}
  .brand .name{font-family:BrotherBold, sans-serif; color:var(--purple); font-size:18px}
  .spacer{flex:1}
  .saved-btn{
    display:inline-flex; align-items:center; gap:8px; border:2px solid var(--purple);
    border-radius:999px; padding:6px 10px; background:transparent; color:var(--purple); font-weight:800; cursor:pointer;
  }
  .badge{
    min-width:20px; height:20px; padding:0 6px; border-radius:999px; background:var(--yellow); color:#000;
    display:inline-flex; align-items:center; justify-content:center; font-size:12px; font-weight:800;
  }

  .wrap{
    height:100%; width:100%; display:grid; place-items:center; padding:60px 16px 24px;
  }
  .gb{
    position:relative;
    width:min(920px, 94vw);
    aspect-ratio: 4/3;
    background: linear-gradient(145deg, var(--shell-light), var(--shell) 40%, var(--shell-dark) 100%);
    border-radius:36px;
    box-shadow: var(--shadow);
    border:6px solid #2c0d76;
  }
  .gb::after{
    content:""; position:absolute; inset:0; border-radius:36px; pointer-events:none;
    box-shadow: inset 0 18px 32px rgba(255,255,255,0.18), inset 0 -18px 28px rgba(0,0,0,0.18);
  }

  .logo-badge{
    position:absolute; left:8%; top:4%;
    display:flex; align-items:center; gap:10px; color:#fff;
    font-family:BrotherBold, sans-serif; letter-spacing:.4px; text-shadow:0 1px 0 rgba(0,0,0,.35);
  }
  .logo-badge img{width:32px; height:32px; filter: drop-shadow(0 1px 0 rgba(0,0,0,.4));}

  .toggle{
    position:absolute; right:8%; top:4%;
    display:inline-flex; border:2px solid #fff; border-radius:999px; overflow:hidden; box-shadow:0 2px 0 rgba(0,0,0,.18);
  }
  .toggle button{
    padding:6px 12px; border:none; background:transparent; color:#fff; font-weight:900; cursor:pointer;
  }
  .toggle button[aria-pressed="true"]{ background:#fff; color:#301873; }

  .screen-bezel{
    position:absolute; left:6%; right:6%; top:7%;
    aspect-ratio:4/3;
    background: linear-gradient(180deg, #222, #111 60%, #000);
    border-radius:22px; padding:14px; box-shadow: inset 0 0 0 2px #000;
  }
  .screen{
    position:relative; width:100%; height:100%; border-radius:12px; display:grid; place-items:center; padding:6px;
  }
  .screen-inner{
    width:100%; height:100%; background:#8CC7FF; border-radius:8px; image-rendering:pixelated; overflow:hidden; position:relative;
  }
  canvas#screen{width:100%; height:100%; display:block; image-rendering:pixelated}
  .screen-label{position:absolute; left:12px; bottom:10px; color:#0b2e0b; font-weight:900; font-size:12px; opacity:.6}
  .hint{position:absolute; top:6px; right:8px; z-index:5; background:#0b2e0b; color:#b6d64b; border:2px solid #215a21; border-radius:6px; padding:4px 6px; font-weight:900; font-size:12px; display:none}
  .hint.show{display:block}

  .dpad{
    position:absolute; left:11%; bottom:10%; width:160px; height:160px; display:grid; place-items:center;
  }
  .stem{position:absolute; background:#24104b; border:3px solid #0b0223; border-radius:12px; box-shadow: inset 0 0 0 2px rgba(255,255,255,0.06), 0 4px 0 rgba(0,0,0,0.25)}
  .stem.vert{width:56px; height:160px}
  .stem.horz{width:160px; height:56px}
  .d-btn{position:absolute; width:56px; height:56px; background: radial-gradient(circle at 35% 35%, #3a1b7a, #230c53); border:2px solid #0b0223; border-radius:10px; color:#fff; font-weight:900; cursor:pointer; display:grid; place-items:center; box-shadow:0 3px 0 rgba(0,0,0,.35)}
  .d-btn:active{transform:translateY(1px)}
  .d-up{top:0; left:52px}
  .d-left{left:0; top:52px}
  .d-right{right:0; top:52px}
  .d-btn span{transform:translateY(-1px)}

  .ab{position:absolute; right:11%; bottom:12%; display:flex; gap:16px; align-items:center}
  .round{width:64px; height:64px; border-radius:50%; background: radial-gradient(circle at 35% 35%, #ffd94d, #c0a300); border:3px solid #6a5c00; box-shadow:0 4px 0 rgba(0,0,0,.35); font-weight:900; color:#000; display:grid; place-items:center; cursor:pointer}
  .round:active{transform:translateY(1px)}

  #saved-panel{
    position:fixed; right:0; top:0; height:100%; width:min(92vw,420px); background:#fff; color:#0f0f12;
    border-left:1px solid rgba(0,0,0,.08); transform:translateX(100%); transition:transform .25s ease; z-index:120; display:grid; grid-template-rows:auto 1fr;
  }
  #saved-panel.open{transform:translateX(0)}
  #saved-panel header{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid rgba(0,0,0,.08)}
  #saved-list{overflow:auto; padding:12px; display:grid; gap:10px}
  .saved-item{border:1px solid rgba(0,0,0,.12); border-radius:12px; padding:12px; display:grid; gap:6px; background:#fff}
  .saved-item .title{font-weight:800; color:var(--purple)}
  .saved-item .meta{color:#3a3a44; font-weight:700}
  .saved-item .row{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px}
  .btn{padding:8px 12px; border-radius:999px; border:2px solid var(--purple); background:transparent; color:var(--purple); font-weight:800; cursor:pointer}
  .btn.primary{background:var(--purple); color:#fff}

  /* tiny badge for tweak mode */
  .tweak-badge{
    position:absolute; right:10px; top:10px; z-index:6;
    background:#000; color:#fff; font-weight:900; font-size:11px; padding:4px 6px; border-radius:6px; opacity:.75; display:none;
  }
  .tweak-on .tweak-badge{ display:block; }
</style>
</head>
<body>

<header class="topbar">
  <div class="brand">
    <img src="./SocialBurstRandomizer/img/logo.png" alt="SocialBurst logo"/>
    <div class="name">SocialBurst</div>
  </div>
  <div class="spacer"></div>
  <button id="btn-saved" class="saved-btn">Saved <span id="saved-count" class="badge">0</span></button>
</header>

<div class="wrap">
  <div class="gb" role="application" aria-label="SocialBurst Game Boy Explorer">
    <div class="logo-badge">
      <img src="./SocialBurstRandomizer/img/logo.png" alt="">
      <div>GAME • BURST</div>
    </div>

    <div class="toggle" role="tablist" aria-label="Category">
      <button id="tab-events" role="tab" aria-pressed="true" aria-selected="true">Events</button>
      <button id="tab-deals" role="tab" aria-pressed="false" aria-selected="false">Deals</button>
    </div>

    <div class="screen-bezel">
      <div class="screen">
        <div class="screen-inner">
          <canvas id="screen" width="256" height="192" aria-label="Game screen"></canvas>
          <div id="hint" class="hint">↑ ENTER</div>
          <div id="tweakBadge" class="tweak-badge">TWEAK: 1=Grass 2=Dirt 3=Rock 4=Cloud 6=Tree 7=Cabin  0=Player • [ / ] cycle</div>
        </div>
        <div class="screen-label">SOCIALBURST DOT MATRIX</div>
      </div>
    </div>

    <div class="dpad" aria-label="D-pad">
      <div class="stem vert"></div>
      <div class="stem horz"></div>
      <button class="d-btn d-up" id="d-up" aria-label="Up"><span>↑</span></button>
      <button class="d-btn d-left" id="d-left" aria-label="Left"><span>←</span></button>
      <button class="d-btn d-right" id="d-right" aria-label="Right"><span>→</span></button>
    </div>

    <div class="ab">
      <button class="round" id="btn-details" title="Open details">A</button>
      <button class="round" id="btn-save" title="Save">B</button>
    </div>
  </div>
</div>

<!-- Details Modal -->
<div id="modal-backdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="modal-title" style="display:none; align-items:center; justify-content:center; padding:16px; z-index:100; position:fixed; inset:0; background:rgba(0,0,0,.45);">
  <div class="modal">
    <header>
      <h2 id="modal-title">Title</h2>
      <button id="modal-close" class="close" aria-label="Close" style="border:none; background:transparent; font-size:24px; line-height:1; cursor:pointer; color:#444;">×</button>
    </header>
    <div class="meta">
      <div id="modal-when" class="btn" style="cursor:default"></div>
      <div id="modal-venue"></div>
      <div id="modal-address"></div>
      <div id="modal-phone"></div>
    </div>
    <div id="modal-desc"></div>
    <div id="modal-links" class="actions"></div>
    <div class="actions" style="margin-top:16px;">
      <button id="modal-save" class="btn primary">Save</button>
      <a id="modal-ics" class="btn" download="event.ics">Add to Calendar</a>
    </div>
  </div>
</div>

<!-- Saved Drawer -->
<aside id="saved-panel" aria-label="Saved items" aria-hidden="true">
  <header>
    <strong>Saved</strong>
    <button id="saved-close" class="btn" aria-label="Close">Close</button>
  </header>
  <div id="saved-list"></div>
</aside>

<!-- Pixel Plaque Overlay -->
<div id="plaque" style="display:none;">
  <div class="plaque-outer" role="dialog" aria-modal="true" aria-label="Event details">
    <button id="plaqueClose" class="plaque-close" aria-label="Close">×</button>
    <div class="plaque-bg"></div>
    <!-- Small canvas → scaled up for crisp pixels -->
    <canvas id="plaqueCanvas" width="160" height="120" aria-hidden="true"></canvas>

    <div class="plaque-actions">
      <a id="plaqueLink" class="btn" target="_blank" rel="noopener">Open link</a>
      <button id="plaqueSave" class="btn primary">Save</button>
    </div>
  </div>
</div>

<style>
/* === PIXEL PLAQUE (single PNG background) === */
#plaque {
  position: fixed;
  inset: 0;
  z-index: 140;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.45);
}
#plaque.show { display: flex; }

.plaque-outer {
  position: relative;
  width: min(480px, 88vw);
  aspect-ratio: 4 / 3;
  image-rendering: pixelated;
  transform: scale(.98);
  animation: plaqueIn .18s ease-out forwards;
}
@keyframes plaqueIn { to { transform: scale(1); } }

/* background wood+paper image UNDER the canvas */
.plaque-bg {
  position: absolute;
  inset: 0;
  background: url("./SocialBurstRandomizer/ui/plaque_board_paper.png") center / contain no-repeat;
  filter: drop-shadow(0 10px 26px rgba(0,0,0,.35));
  pointer-events: none;
  z-index: 0;
}

/* canvas MUST be above the paper image */
#plaqueCanvas {
  position: absolute;
  left: 9%;
  right: 9%;
  top: 10%;
  bottom: 14%;
  display: block;
  width: auto;
  height: auto;
  image-rendering: pixelated;
  z-index: 1;
}

/* hide the DOM buttons; we’re drawing pixel buttons on the canvas */
.plaque-actions { display: none; }

.plaque-close {
  position: absolute;
  right: 6px;
  top: 6px;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 6px;
  background: #000;
  color: #fff;
  font-weight: 900;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 0 rgba(0,0,0,.35);
  z-index: 2; /* keep on top */
}
</style>
<script>
/* ================= BASIC CONFIG ================= */

var CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQi9O78dGEZQ38WWiuMBKKNJwlp6J-yLmPP2lCjJJAHifG1YnpIPVvGt9tKdULSC4ZW9CBiIQOTOx7L/pub?gid=1474444500&single=true&output=csv";
var TILE = 16, GROUND_Y = 136;
var CAP_H = 16;                  // grass cap height (tile)
var GRASS_PAD = 5;        
var DIRT_OVERLAP = 1;      
var GROUND_SURFACE_Y = GROUND_Y - CAP_H;

// --- RANDOM SEED SYSTEM ---
// Gives a new random layout each time the page loads
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }


// New random seed every load (you can later swap this for a saved seed if you want consistency)
const RUN_SEED = (window.crypto && crypto.getRandomValues)
  ? crypto.getRandomValues(new Uint32Array(1))[0]
  : (Date.now() ^ (Math.random()*0x7fffffff)|0);

// Actual RNG functions
const rand = mulberry32(RUN_SEED);
function r01(){ return rand(); }
function rint(min,max){ return Math.floor(r01()*(max-min+1))+min; }
function rpick(arr){ return arr[Math.floor(r01()*arr.length)]; }

var PHYS = {
  // horizontal tuning
  walkSpeed: 100,          // was 60
  runMultiplier: 1.35,     // hold Shift to sprint
  accelGround: 900,        // px/s^2
  accelAir: 450,           // weaker in air → preserves momentum
  frictionGround: 700,     // px/s^2 when no input
  frictionAir: 140,        // small air drag

  // jump carry
  jumpCarry: 40,           // tiny horizontal boost on takeoff

  // existing
  deadzone: 36,
  gravity: 900,
  jumpVel: 420,
  termVel: 800,
  coyoteTime: 0.08,
  jumpBuffer: 0.12
};
var GRASS_OVERLAP = 0;          // we’re not using overlap anymore
var GRASS_SEAM_SHADOW = 0x3b2a4e; // keep if you like, but we won’t draw seam lines
/* PATCH START: define keys state */
var keys = { left:false, right:false, up:false, jump:false, shift:false };
/* PATCH END */
/* === PLAYER SPRITE CONFIG (folders + filenames) === */
var PLAYER_SPR = {
  scale: 0.85,   // bump to 2 if sprite is tiny

  idle: { dir: "south", frames: ["0.png","1.png","2.png","3.png"], fps: 6 },
  walk: { dir: "east",  frames: ["0.png","1.png","2.png","3.png","4.png","5.png"], fps: 10 },

  // NEW: 9-frame jump
  jump: { dir: "jump",  frames: ["0.png","1.png","2.png","3.png","4.png","5.png","6.png","7.png","8.png"], fps: 18 }
};

// runtime containers
var playerGfx = {
  idleFrames: [],
  walkFrames: [],
  jumpFrames: [],
  ready: false
};

// simple animation clock/state
var anim = { t: 0, state: "idle", playedJumpOnce: false };
function setAnim(state){
  if (anim.state !== state){
    anim.state = state;
    anim.t = 0; // reset the state clock on change
  }
}
/* ================= ELEMENTS ================= */
var canvas = document.getElementById('screen');
var ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
var hintEl = document.getElementById('hint');
var tweakBadge = document.getElementById('tweakBadge');

var tabEvents = document.getElementById('tab-events');
var tabDeals  = document.getElementById('tab-deals');
var dUp   = document.getElementById('d-up');
var dLeft = document.getElementById('d-left');
var dRight= document.getElementById('d-right');
var btnA = document.getElementById('btn-details');
var btnB = document.getElementById('btn-save');

var btnSaved = document.getElementById('btn-saved');
var savedCountEl = document.getElementById('saved-count');
var savedPanel = document.getElementById('saved-panel');
var savedClose = document.getElementById('saved-close');
var savedList  = document.getElementById('saved-list');

var modalBackdrop = document.getElementById('modal-backdrop');
var modalTitle = document.getElementById('modal-title');
var modalWhen = document.getElementById('modal-when');
var modalVenue = document.getElementById('modal-venue');
var modalAddress = document.getElementById('modal-address');
var modalPhone = document.getElementById('modal-phone');
var modalDesc = document.getElementById('modal-desc');
var modalLinks = document.getElementById('modal-links');
var modalIcs = document.getElementById('modal-ics');
var modalClose = document.getElementById('modal-close');
var modalSave = document.getElementById('modal-save');

// === Plaque elements ===
var plaque = document.getElementById('plaque');
var plaqueCanvas = document.getElementById('plaqueCanvas');
var plaqueCtx = plaqueCanvas.getContext('2d');
plaqueCtx.imageSmoothingEnabled = false;
var plaqueLink = document.getElementById('plaqueLink');
var plaqueSave = document.getElementById('plaqueSave');
var plaqueClose = document.getElementById('plaqueClose');

// Lock gameplay while plaque is open
var UI_LOCK = false;

/* ================= STATE ================= */
var CATEGORY='events', EVENTS=[], DEALS=[], ITEMS=[];
var worldW=256*6, cameraX=0, cameraY=0, canEnterId=null, currentOpen=null;
var WORLD_H = 1200;   // rough world height; tweak later
var VDEADZONE = 40;   // vertical deadzone like horizontal
var WORLD_TOP = -800, WORLD_BOTTOM = 0; // vertical clamp; updated after building platforms

// Vertical framing bias (fraction of canvas height above the player)
var camBias = {
  current: 0.50,   // start near center
  target:  0.50,   // where we want to go
  lerp:    6       // how fast we ease (units: 1/sec)
};

/* Player */
var player = {
  x: 16,
  y: GROUND_Y,
  vx: 0,
  vy: 0,
  step: 0,
  facing: 1,
  grounded: true,
  coyote: 0,          // timer
  jumpBuffer: 0       // timer
};
// --- Jump helpers (top-level, used by key handlers and physics) ---
function requestJump(){
  // buffer the intent; update() will consume it if possible
  player.jumpBuffer = PHYS.jumpBuffer;
}

function doJump(){
  player.vy = -PHYS.jumpVel;
  player.grounded = false;
  player.coyote = 0;
  setAnim("jump");
  anim.playedJumpOnce = false;

  // preserve momentum + tiny boost
  if (Math.abs(player.vx) > 0) {
    player.vx += player.facing * PHYS.jumpCarry;
  }
} // ✅ CLOSE THIS HERE

function landOn(surfaceY){
  player.y = surfaceY;
  player.vy = 0;
  if (!player.grounded){
    player.grounded = true;
  }
  player.coyote = PHYS.coyoteTime;
  setAnim((player.vx !== 0) ? "walk" : "idle");
}
/* Parallax */
var parallax = { cloudsNearX:0, cloudsFarX:0, treeX:0 };

/* Scene */
/* Scene */
var houses=[], pines=[];

/* One-way platform segments (world coordinates) */
var PLATFORMS = [];

// Minimal stub map (only for pixel fallback)
var map = { player: 65 };
/* === LOAD PER-FRAME PNGs === */
function loadImage(url){
  return new Promise(function(resolve){
    var img = new Image();
    img.onload = function(){ resolve(img); };
    img.onerror = function(){
      console.warn("Missing sprite:", url);
      resolve(null); // don't reject; keep boot alive
    };
    img.src = url;
  });
}

function loadPlayerSprites(){
  var base = "./SocialBurstRandomizer/sprites/player/";

  function loadImage(url){
    return new Promise(function(resolve){
      var img = new Image();
      img.onload = function(){ resolve(img); };
      img.onerror = function(){ console.warn("Missing sprite:", url); resolve(null); };
      img.src = url;
    });
  }

  var idlePromises = PLAYER_SPR.idle.frames.map(function(f){
    return loadImage(base + PLAYER_SPR.idle.dir + "/" + f);
  });
  var walkPromises = PLAYER_SPR.walk.frames.map(function(f){
    return loadImage(base + PLAYER_SPR.walk.dir + "/" + f);
  });
  var jumpPromises = PLAYER_SPR.jump.frames.map(function(f){
    return loadImage(base + PLAYER_SPR.jump.dir + "/" + f);
  });

  return Promise.all([
    Promise.all(idlePromises),
    Promise.all(walkPromises),
    Promise.all(jumpPromises)
  ])
  .then(function(res){
    playerGfx.idleFrames = res[0].filter(Boolean);
    playerGfx.walkFrames = res[1].filter(Boolean);
    playerGfx.jumpFrames = res[2].filter(Boolean);
    playerGfx.ready = !!(playerGfx.idleFrames.length && playerGfx.walkFrames.length && playerGfx.jumpFrames.length);
  })
  .catch(function(err){
    console.warn("Player sprite load failed:", err);
    playerGfx.ready = false;
  });
}
/* ================= BOOT ================= */
window.addEventListener('DOMContentLoaded', function(){
  wireUI();
Promise.all([
  loadPlayerSprites(),
  hydrate()
])
  .catch(function(err){
    console.warn("Boot continuing despite error:", err);
  })
  .then(function(){
    setCategory('events');
    updateSavedBadge();
    requestAnimationFrame(loop);
  });
});
function wireUI(){
  tabEvents.onclick=function(){ setCategory('events'); };
  tabDeals.onclick=function(){ setCategory('deals'); };

 /* PATCH START: dpad continuous press */
  function hold(el, on, off){
    var down=false, id=null;
    var start=function(e){ e.preventDefault(); down=true; on(); };
    var stop=function(e){ e && e.preventDefault(); if(down){ down=false; off(); } };
    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start, {passive:false});
    window.addEventListener('mouseup', stop);
    window.addEventListener('touchend', stop);
    window.addEventListener('touchcancel', stop);
  }
  hold(dLeft,  function(){ keys.left=true; },  function(){ keys.left=false; });
  hold(dRight, function(){ keys.right=true; }, function(){ keys.right=false; });
  dUp.addEventListener('click', function(e){ e.preventDefault(); tryEnter(); });
/* PATCH END */

  btnA.onclick=function(e){
  e.preventDefault();
  requestJump();
};
  btnB.onclick=function(){ if (currentOpen) saveItem(currentOpen); };

  /* PATCH START: keyboard -> keys state */
  document.addEventListener('keydown', function(e){
    if (modalBackdrop.style.display==='flex'){
      if (e.key==='Escape') closeModal();
      if (e.key==='b'||e.key==='B'){ if(currentOpen) saveItem(currentOpen); }
      return;
    }
    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') keys.left = true;
    if (e.key==='ArrowRight'|| e.key==='d' || e.key==='D') keys.right= true;
    if (e.key==='ArrowUp'   || e.key==='w' || e.key==='W' || e.key==='Enter') keys.up=true;
    if (e.key === 'Shift') keys.shift = true;

// === ADD: Jump controls ===
if (e.code === 'Space') {
  e.preventDefault();
  requestJump();
}
if (e.key === 'z' || e.key === 'Z') {
  requestJump();
}
// === END ADD ===


    // Tweak mode (unchanged)

  });
  document.addEventListener('keyup', function(e){
    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') keys.left = false;
    if (e.key==='ArrowRight'|| e.key==='d' || e.key==='D') keys.right= false;
    if (e.key==='ArrowUp'   || e.key==='w' || e.key==='W' || e.key==='Enter') keys.up=false;
    if (e.key === 'Shift') keys.shift = false;
  });
/* PATCH END */

  btnSaved.onclick=toggleSavedPanel;
  savedClose.onclick=function(){ setSavedPanel(false); };

  modalBackdrop.addEventListener('click', function(ev){ if (ev.target===modalBackdrop) closeModal(); });
  modalClose.onclick=closeModal;
  modalSave.onclick=function(){ if (currentOpen) saveItem(currentOpen); };
}

/* ================= ATLAS ================= */


/* Standalone cabin image */
var imgCabin = new Image();
var cabinReady = false;
imgCabin.onload = function(){ cabinReady = true; };
imgCabin.src = './SocialBurstRandomizer/sprites/buildings/cabin.png';

/* === Tavern Building === */
var imgTavern = new Image();
var tavernReady = false;
imgTavern.onload = function(){ tavernReady = true; };
imgTavern.src = './SocialBurstRandomizer/sprites/buildings/tavern.png';

/* === Restaurant Building === */
var imgRestaurant = new Image();
var restaurantReady = false;
imgRestaurant.onload = function(){ restaurantReady = true; };
imgRestaurant.src = './SocialBurstRandomizer/sprites/buildings/restaurant.png';
/* === GRASS + DIRT TILES (16x16, side-view) === */
var imgGrass = new Image(), grassReady = false;
imgGrass.onload = function(){ grassReady = true; };
imgGrass.src = './SocialBurstRandomizer/sprites/tiles/grass_cap.png';

var imgDirt  = new Image(), dirtReady = false, dirtPattern = null;
imgDirt.onload = function(){
  dirtReady = true;
  // repeat in both directions; it's a seamless tile
  dirtPattern = ctx.createPattern(imgDirt, 'repeat');
};
imgDirt.src = './SocialBurstRandomizer/sprites/tiles/dirt_fill.png';

/* ======= ABBEY BG (parallax landmark) ======= */
var imgAbbeyBG = new Image();
var abbeyBGReady = false;
imgAbbeyBG.onload = function(){ abbeyBGReady = true; };
imgAbbeyBG.src = './SocialBurstRandomizer/sprites/backgrounds/abbey_bg.png';

var ABBEY_BG = {
  scale: 0.95,   // makes it span the screen width cleanly
  parallax: 0.18, // subtle parallax (smaller = more distant)
  offsetX: 0,     // we’ll center in screen-space (no world push)
  offsetY: -6
};

/* ================= CSV & DATA ================= */
function hydrate(){
  const url = CSV_URL + (CSV_URL.includes('?') ? '&' : '?') + 'cb=' + Date.now();
  return fetch(url, {cache:'no-store'})
    .then(function(r){ if(!r.ok) throw new Error(r.status); return r.text(); })
    .then(function(text){
      var rows = csvToObjects(text);
      var p = partition(rows);
      EVENTS=p.events; DEALS=p.deals;
      if(!EVENTS.length && !DEALS.length){ var fb=fallback(); EVENTS=fb.events; DEALS=fb.deals; }
    })
    .catch(function(){
      var fb=fallback(); EVENTS=fb.events; DEALS=fb.deals;
    });
}
function csvToObjects(text){
  if(!text||!text.trim()) return [];
  var rows = csvRows(text);
  if(!rows.length) return [];
  var headers = rows[0].map(function(h){return String(h||'').trim().toLowerCase();});
  var out=[];
  for(var i=1;i<rows.length;i++){
    var r=rows[i]; if(r.every(function(c){return !String(c||'').trim();})) continue;
    var o={}; for(var j=0;j<headers.length;j++) o[headers[j]||('col_'+j)]=(r[j]==null?'':String(r[j])).trim();
    out.push(normalize(o,i));
  }
  return out;
}
function csvRows(text){
  var rows=[],cur='',row=[],q=false;
  for(var i=0;i<text.length;i++){
    var ch=text[i], nx=text[i+1];
    if(ch==='"'){ if(q && nx==='"'){cur+='"'; i++;} else q=!q; }
    else if(ch===',' && !q){ row.push(cur); cur=''; }
    else if((ch==='\n'||ch==='\r') && !q){ if(ch==='\r'&&nx==='\n') i++; row.push(cur); rows.push(row); row=[]; cur=''; }
    else cur+=ch;
  }
  row.push(cur); rows.push(row); return rows;
}
function normalize(obj, idx){
  function pick(keys,def){ for(var k=0;k<keys.length;k++){ var v=obj[keys[k]]; if(v!=null && String(v).trim()!=='') return String(v).trim(); } return def||''; }
  var type = pick(['type','category'],'').toLowerCase()==='deal' ? 'deal' : 'event';
  var title=pick(['title','name'])||'Untitled';
  var venue=pick(['venue','venue_name','business','place']);
  var when =pick(['when','time','window','start_datetime']);
  var desc =pick(['description','details','desc']);
  var link =pick(['link','url','website','source_url']);
  var addr =pick(['address','addr','location']);
  var phone=pick(['phone','tel','telephone']);
  var s=parseTime(pick(['start_datetime'],''));
  var e=parseTime(pick(['end_datetime'],''));
  if(s||e){
    var sTxt=s?s.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}):'';
    var eTxt=e?e.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}):'';
    if(s&&e) when='Today '+sTxt+'–'+eTxt;
    else if(s) when='Today '+sTxt;
    else if(e) when='Until '+eTxt+' today';
  }
  return { id:hashId(title+'|'+venue+'|'+when+'|'+idx),
           type:type, title:title, venue:venue||'', when:when||'Today',
           description:desc||'', short:'', link:link||undefined, address:addr||undefined, phone:phone||undefined };
}
function parseTime(s){
  var t=String(s||'').toLowerCase().replace(/\u00a0|\u202f/g,' ').trim();
  var m=t.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm|a\.m\.|p\.m\.)?\s+(\d{1,2})\/(\d{1,2})$/i);
  if(!m) return null;
  var h=parseInt(m[1],10), mm=m[2]?parseInt(m[2],10):0, ap=(m[3]||'').replace(/\./g,'').toLowerCase();
  var d=parseInt(m[4],10), mo=parseInt(m[5],10), y=(new Date()).getFullYear();
  if(ap==='pm'&&h<12)h+=12; if(ap==='am'&&h===12)h=0;
  var dt=new Date(y,mo-1,d,h,mm,0,0); return isNaN(+dt)?null:dt;
}
function partition(items){
  var ev=[],de=[]; for(var i=0;i<items.length;i++) (items[i].type==='deal'?de:ev).push(items[i]);
  return {events:ev, deals:de};
}
function fallback(){
  return {
    events:[
      {id:'e1', type:'event', title:'Pub Quiz Night', when:'Today 19:30–21:30', venue:'The Jolly Sailor', description:'£50 bar tab • Teams up to 6', link:'#'},
      {id:'e2', type:'event', title:'Open Mic', when:'Today 20:00–22:30', venue:'The Horn', description:'Sign-ups from 19:00', link:'#'},
      {id:'e3', type:'event', title:'Board Game Social', when:'Today 18:00–22:00', venue:'White Lion', description:'Bring a game or join a table', link:'#'}
    ],
    deals:[
      {id:'d1', type:'deal', title:'2-for-1 Pizzas', when:'Valid until 17:00', venue:'Pinsa Lab', description:'Dine-in only', link:'#'},
      {id:'d2', type:'deal', title:'£5 Cocktails', when:'Today 17:00–19:00', venue:'Peahen', description:'House list only', link:'#'}
    ]
  };
}

/* ================= WORLD GEN ================= */
function setCategory(kind){
  CATEGORY=(kind==='deals')?'deals':'events';
  tabEvents.setAttribute('aria-pressed', String(CATEGORY==='events'));
  tabDeals.setAttribute('aria-pressed',  String(CATEGORY==='deals'));
  tabEvents.setAttribute('aria-selected', String(CATEGORY==='events'));
  tabDeals.setAttribute('aria-selected',  String(CATEGORY==='deals'));

  ITEMS=(CATEGORY==='events'?EVENTS:DEALS).slice();
  buildScene();
  player.x=16; cameraX=0; cameraY=0; canEnterId=null;
}

// Height helper: works whether you use the PNG cabin or the tiles
function getHouseHeight(h){
  // If you're drawing a PNG cabin, prefer its real height
  if (h.kind === 'cabin' && typeof window.imgCabin !== 'undefined' && window.imgCabin){
    return window.imgCabin.height || h.h;
  }
  // Defaults from the tileset (cabin 3 tiles high = 48px)
  return h.h;
}

// Recompute vertical camera bounds so tall buildings fit
function recomputeWorldBounds(){
  // Find the highest (smallest) top edge among all houses
  var minTop = GROUND_Y; // start at ground
  for (var i=0;i<houses.length;i++){
    var baseY = (typeof houses[i].baseY === 'number') ? houses[i].baseY : GROUND_Y;
    var topY  = baseY - getHouseHeight(houses[i]); // world Y of roof peak/top
    if (topY < minTop) minTop = topY;
  }

  // Give a little margin above the tallest sprite
  var margin = 24; // pixels of headroom
  // Allow camera to scroll up to just above that top
  WORLD_TOP = Math.min(WORLD_TOP, Math.round(minTop - margin));
  // Bottom stays the ground area
  WORLD_BOTTOM = 0;
}

function buildScene(){
  buildHouses(); 
  buildParallax();
  buildPlatforms();   // NEW
  placeHousesOnPlatforms(); // NEW
  recomputeWorldBounds();
}
function buildHouses(){
  houses = [];

  // Where to start placing houses and how far apart they are (both randomized each load)
  let xStart = rint(40, 70);
  let gapMin = 110, gapMax = 150;

  const list = (CATEGORY === 'events' ? EVENTS : DEALS);
  const KINDS = ['cabin','tavern','restaurant'];

  // helper to avoid repeating the same kind twice in a row
  function pickKind(prev){
    let k;
    do { k = rpick(KINDS); } while (k === prev && KINDS.length > 1);
    return k;
  }

  let x = xStart;
  let prevKind = null;

  for (let i = 0; i < list.length; i++){
    const it = list[i];

    // 4x3 tile footprint – drawing code handles PNG sizes
    const w = 4 * TILE;
    const h = 3 * TILE;

    const kind = pickKind(prevKind);
    prevKind = kind;

    houses.push({
      id: it.id,
      title: it.title,
      when: it.when,
      x: x,
      w: w,
      h: h,
      kind: kind
    });

    x += rint(gapMin, gapMax);
  }

  // extend world width to fit the last house + margin
  worldW = Math.max(256, houses.length ? (houses[houses.length - 1].x + 160) : 256);
}

function buildParallax(){ pines = []; }
function buildPlatforms(){
  PLATFORMS = [];

  // --- derive safe reach from your PHYS values ---
  const vy0 = PHYS.jumpVel;                  // px/s
  const g   = PHYS.gravity;                  // px/s^2
  const tUp = vy0 / g;                       // time up
  const tAir = 2 * tUp;                      // up + down
  const horizSpeed = PHYS.walkSpeed * PHYS.runMultiplier * 0.95; // conservative
  const maxHoriz = Math.max(80, Math.min(200, horizSpeed * tAir));
  const maxRise  = (vy0 * vy0) / (2 * g);    // theoretical max climb
  const stepY    = Math.round(Math.min(88, maxRise * 0.75));     // safe climb per step

  // platform size + world bounds
  const width  = 104;
  const margin = 32;

  // first platform: comfortably above ground and near the player
  let x = rint(48, 120);
  let y = GROUND_Y - rint(stepY - 6, stepY + 6);

  // how many to try to place
  const count = 12 + rint(0, 4);
  let dir = rpick([+1, -1]);  // start going left or right

  for (let i = 0; i < count; i++){
    PLATFORMS.push({ x, y, w: width, h: 16, row: i });

    // propose a next platform; resample until reachable
    let tries = 0;
    while (tries++ < 20){
      const gapX = rint(Math.max(70, Math.floor(maxHoriz*0.45)),
                        Math.min(160, Math.floor(maxHoriz*0.75)));
      const nx = x + dir * gapX;
      const ny = y - rint(stepY - 10, stepY + 10);

      // keep inside world
      const nxClamped = Math.max(margin, Math.min(worldW - width - margin, nx));

      // compute reach from current to proposed
      const dx = Math.abs((nxClamped + width/2) - (x + width/2));
      const dy = Math.max(0, y - ny); // positive = going up

      const reachable = (dx <= maxHoriz) && (dy <= stepY + 2);

      if (reachable){
        x = nxClamped;
        y = ny;
        break;
      }

      // flip direction if we bounced into a wall or repeatedly fail
      if (tries % 6 === 0) dir *= -1;
    }

    // occasionally flip direction to zig-zag
    if (r01() < 0.25) dir *= -1;
  }

  // tighten vertical camera range based on platforms
  const minY = PLATFORMS.reduce((m, p) => Math.min(m, p.y), GROUND_Y);
  WORLD_TOP = Math.min(-800, Math.round(minY - 80));
  WORLD_BOTTOM = 0;
}

function placeHousesOnPlatforms(){
  if (!houses.length) return;

  const hasPlatforms = PLATFORMS && PLATFORMS.length > 0;
  let nextPlat = 0;

  for (let i = 0; i < houses.length; i++){
    const h = houses[i];

    if (hasPlatforms && r01() > 0.5){           // random each load
      const p = PLATFORMS[nextPlat % PLATFORMS.length];
      nextPlat++;
      h.baseY = p.y;                            // sit ON platform grass (feet line)
      h.x = p.x + (p.w / 2);
    } else {
      h.baseY = GROUND_Y;                       // sit ON ground grass (feet line)
    }
  }
}


/* ================= GAME LOOP ================= */
/* PATCH START: dt loop + acceleration physics */
var _lastT = performance.now();
function loop(){
  var now = performance.now();
  var dt  = Math.min(0.05, (now - _lastT) / 1000); // clamp 50ms
  _lastT = now;

  update(dt);
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  // --- HORIZONTAL (unchanged feel) ---
  // --- HORIZONTAL (momentum) ---
var input = 0;
if (keys.left)  input -= 1;
if (keys.right) input += 1;

if (UI_LOCK) { render(); return; }

var maxSpeed = PHYS.walkSpeed * (keys.shift ? PHYS.runMultiplier : 1);
var target   = maxSpeed * input;
var accel    = player.grounded ? PHYS.accelGround : PHYS.accelAir;

// accelerate towards target (clamped per-frame)
var delta = target - player.vx;
var maxDelta = accel * dt;
if (Math.abs(delta) > maxDelta) delta = Math.sign(delta) * maxDelta;
player.vx += delta;

// friction if no input
if (input === 0) {
  var fr = (player.grounded ? PHYS.frictionGround : PHYS.frictionAir) * dt;
  if (Math.abs(player.vx) <= fr) player.vx = 0;
  else player.vx -= Math.sign(player.vx) * fr;
}

player.x += player.vx * dt;
if (player.vx !== 0) player.facing = (player.vx > 0 ? 1 : -1);

  if (player.x < 0) player.x = 0;
  if (player.x > worldW - 8) player.x = worldW - 8;

  // --- COYOTE & BUFFER TIMERS ---
  if (!player.grounded){
    player.coyote = Math.max(0, player.coyote - dt);
  } else {
    player.coyote = PHYS.coyoteTime;
  }
  if (player.jumpBuffer > 0) {
    player.jumpBuffer = Math.max(0, player.jumpBuffer - dt);
  }

  // --- VERTICAL PHYSICS ---
   // --- VERTICAL PHYSICS ---
  if (!player.grounded){
    player.vy += PHYS.gravity * dt;
    if (player.vy > PHYS.termVel) player.vy = PHYS.termVel;
  }

  var prevY = player.y;   // <— add this
  player.y += player.vy * dt;

  // --- One-way platform collisions: land only when falling and crossing top surface ---
  var landedOnPlatform = false;
  if (player.vy >= 0){ // falling or resting
    for (var i=0;i<PLATFORMS.length;i++){
      var p = PLATFORMS[i];
      var withinX = (player.x >= p.x) && (player.x <= p.x + p.w);
      var crossedTop = (prevY <= p.y) && (player.y >= p.y);
      if (withinX && crossedTop){
            landOn(p.y);
      landedOnPlatform = true;
      break;
      }
    }
  }
  
  // ground collision at GROUND_Y
  if (!landedOnPlatform){
    if (player.y >= GROUND_Y){
      player.y = GROUND_Y;
      player.vy = 0;
      if (!player.grounded){
        player.grounded = true;
        // if a jump was buffered just before landing, consume it now
        if (player.jumpBuffer > 0){
          player.jumpBuffer = 0;
          doJump();
          player.grounded = false;
        }
      }
    } else {
      player.grounded = false;
    }
  }


  // --- CONSUME JUMP BUFFER while airborne but within coyote time (leaving edges)
  if (player.jumpBuffer > 0 && (player.grounded || player.coyote > 0)){
    player.jumpBuffer = 0;
    doJump();
  }

  // --- ANIMATION STATE ---
if (!player.grounded){
  setAnim((player.vy < 0) ? "jump" : "fall");
} else {
  setAnim((player.vx !== 0) ? "walk" : "idle");
}
anim.t += dt;

  // simple legacy step (used by pixel fallback)
  if (player.vx !== 0) { player.step = (player.step + 10*dt) % 2; } else { player.step = 0; }

  // --- CAMERA ---
  var leftDZ  = (player.x - PHYS.deadzone) - canvas.width/2;
  var rightDZ = (player.x + PHYS.deadzone) - canvas.width/2;
  if (cameraX > leftDZ)  cameraX = Math.max(leftDZ, cameraX - 120*dt);
  if (cameraX < rightDZ) cameraX = Math.min(rightDZ, cameraX + 120*dt);
  if (cameraX < 0) cameraX = 0;
  if (cameraX > worldW - canvas.width) cameraX = worldW - canvas.width;

  // --- Decide vertical framing based on where the player is ---
// Rule of thumb:
// - On ground level → keep player nearer the center (0.55)
// - Up on higher platforms → push camera up (0.70) so more headroom (player lower)
// - While rising quickly, give a little extra look-ahead (0.45) so you see where you’re going
var highThreshold = GROUND_Y - 40;   // consider "high" once player is ~40px above ground
var risingFast    = player.vy < -120;

if (risingFast){
  camBias.target = 0.45;             // small look-ahead upwards while jumping up
} else if (player.y < highThreshold){
  camBias.target = 0.70;             // you’re up high → keep the view higher
} else {
  camBias.target = 0.55;             // ground-ish → near center
}

// Ease the bias so it doesn’t pop
camBias.current += (camBias.target - camBias.current) * Math.min(1, camBias.lerp * dt);

// Apply the bias to the camera target
var targetY = player.y - canvas.height * camBias.current;


// faster catch-up when rising, softer when falling
var k = (player.vy < 0 ? 28 : 16) * dt;   // was 14*dt
if (k > 1) k = 1;
cameraY += (targetY - cameraY) * k;



// clamp to world limits
if (cameraY < WORLD_TOP)    cameraY = WORLD_TOP;
if (cameraY > WORLD_BOTTOM) cameraY = WORLD_BOTTOM;

  // --- PARALLAX ---

  parallax.treeX = cameraX * 0.5;

  // --- ENTER detection unchanged ---
  var aligned = null;
  for (var i=0;i<houses.length;i++){
    var door = doorXFor(houses[i]);
    if (Math.abs(door - player.x) < 8){ aligned = houses[i]; break; }
  }
  if (aligned && player.grounded){ // only show hint when on ground
    canEnterId = aligned.id; hintEl.classList.add('show');
  } else {
    canEnterId = null; hintEl.classList.remove('show');
  }

  if (keys.up && canEnterId){ tryEnter(); keys.up = false; }
}

/* ================= RENDER ================= */
function render(){
  // wipe frame completely
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // SKY gradient
  var top = 0xBDE4FF, mid = 0x8CC9FF, bot = 0x6BB1F4;
  for (var y = 0; y < canvas.height; y++) {
    var t = y / canvas.height;
    var hex = (t < 0.5)
      ? lerpRGB(top, mid, t / 0.5)
      : lerpRGB(mid, bot, (t - 0.5) / 0.5);
    horizLine(0, y, canvas.width, hex);
  }

  // ❌ no cloud tiling, no treeline while we wait for real assets
  if (abbeyBGReady) drawAbbeyBG(); // keep your Abbey landmark

  // Ground + platforms (no grass caps)
  drawGround();
  drawPlatforms();


  // Buildings
  for (var h = 0; h < houses.length; h++){
    drawBuilding(houses[h]);
  }

  // Player
  drawPlayer(Math.round(player.x - cameraX), Math.round(player.y - cameraY));
}


// Draw the St Albans Abbey landmark (single sprite, parallaxed)
function drawAbbeyBG(){
  if (!abbeyBGReady) return;

  const par = (ABBEY_BG.parallax == null ? 0.18 : ABBEY_BG.parallax);

  // How far the background is allowed to drift across the whole world
  const maxDrift = Math.max(0, (worldW - canvas.width) * par);

  // Make the image wide enough to still cover the canvas at max drift
  const minWidth  = canvas.width + Math.ceil(maxDrift) + 2; // +2 safety for rounding
  const baseScale = ABBEY_BG.scale || 1;
  const s         = Math.max(baseScale, minWidth / imgAbbeyBG.width);

  const w = Math.round(imgAbbeyBG.width  * s);
  const h = Math.round(imgAbbeyBG.height * s);

  // LEFT-ANCHORED: at cameraX=0 the image’s left edge sits at x=0 (plus optional offset)
  let x = Math.round(-cameraX * par + (ABBEY_BG.offsetX || 0));

  // Clamp so neither edge ever shows, but only *after* you’ve used up the drift
  // (allows full parallax, then "locks" at the extreme).
  x = Math.min(0, Math.max(canvas.width - w, x));

  const baseY = GROUND_Y + (ABBEY_BG.offsetY || 0);
  const y = Math.round((baseY - h) - cameraY);

  ctx.drawImage(imgAbbeyBG, x, y, w, h);
}

function doorXFor(h){
  var half = h.w / 2;
  if (h.kind === 'cabin')      return h.x - half + TILE * 1.5; // left-ish door
  if (h.kind === 'tavern')     return h.x;                     // centered
  if (h.kind === 'restaurant') return h.x + half - TILE * 1.5; // right-ish
  return h.x;
}

function drawPlatforms(){
  for (var i = 0; i < PLATFORMS.length; i++){
    var p  = PLATFORMS[i];
    var sx = Math.round(p.x - cameraX);
    var sy = Math.round(p.y - cameraY);   // p.y = walking surface (cap bottom)

    // DIRT: lift to touch cap and add a tiny overlap
    var dirtTop = sy - (GRASS_PAD + DIRT_OVERLAP);
    var ph      = 16 + GRASS_PAD + DIRT_OVERLAP;
    if (dirtReady){
      for (var xx = sx; xx < sx + p.w; xx += TILE){
        ctx.drawImage(imgDirt, xx, dirtTop, TILE, ph);
      }
    } else {
      fillRect(sx, dirtTop, p.w, ph, 0x6b4a2f);
    }

    // optional: single pixel seam (same color as dirt) behind the grass
    fillRect(sx, sy - 1, p.w, 1, 0x6b4a2f);

    // GRASS cap sits on top
    if (grassReady){
      for (var gx = sx; gx < sx + p.w; gx += TILE){
        ctx.drawImage(imgGrass, gx, sy - CAP_H, TILE, TILE);
      }
    }
  }
}
function drawGround(){
  var groundTop = Math.round(GROUND_Y - cameraY);      // cap bottom
  var startX    = - (Math.round(cameraX) % TILE);      // world-locked

  // DIRT: lift + overlap
  var dirtTop = groundTop - (GRASS_PAD + DIRT_OVERLAP);

  if (dirtReady){
    for (var y = dirtTop; y < canvas.height; y += TILE){
      for (var x2 = startX; x2 < canvas.width + TILE; x2 += TILE){
        ctx.drawImage(imgDirt, x2, y, TILE, TILE);
      }
    }
  } else {
    fillRect(0, dirtTop, canvas.width, canvas.height - dirtTop, 0x6b4a2f);
  }

  // 1-px seam behind the grass to cover any rounding
  fillRect(0, groundTop - 1, canvas.width, 1, 0x6b4a2f);

  // GRASS cap on top
  if (grassReady){
    for (var x = startX; x < canvas.width + TILE; x += TILE){
      ctx.drawImage(imgGrass, x, groundTop - CAP_H, TILE, TILE);
    }
  }
}
// Per-building vertical nudges to correct PNG padding
var BUILDING_Y_NUDGE = {
  cabin: 0,
  tavern: 0,
  restaurant: 6   // ⬅️ move the restaurant DOWN 6px so it sits on the grass
};
function drawBuilding(h){
  var screenX = Math.round(h.x - cameraX);
  var baseY   = (typeof h.baseY === "number") ? h.baseY : GROUND_Y;
  var x = screenX - Math.floor(h.w / 2);
  var y = Math.round((baseY - h.h) - cameraY); y += (BUILDING_Y_NUDGE[h.kind] || 0);
  var s = 0.85; // consistent scale for all buildings

  if (h.kind === 'cabin'){
    if (cabinReady){
      var w = Math.round(imgCabin.width * s);
      var dh = Math.round(imgCabin.height * s);
      ctx.drawImage(imgCabin, x + Math.floor((64 - w) / 2), y - (dh - 48), w, dh);
    }
    // no fallback
  }
  else if (h.kind === 'tavern'){
    if (tavernReady){
      var w2 = Math.round(imgTavern.width * s);
      var dh2 = Math.round(imgTavern.height * s);
      ctx.drawImage(imgTavern, x + Math.floor((64 - w2) / 2), y - (dh2 - 48), w2, dh2);
    }
    // no fallback
  }
  else if (h.kind === 'restaurant'){
    if (restaurantReady){
      var w3 = Math.round(imgRestaurant.width * s);
      var dh3 = Math.round(imgRestaurant.height * s);
      ctx.drawImage(imgRestaurant, x + Math.floor((64 - w3) / 2), y - (dh3 - 48), w3, dh3);
    }
    // no fallback
  }

  // Title above each building
  pixelText(h.title.toUpperCase(), x, y - 10, 0x143C0D, h.w);
}

function drawPlayer(x, y){

  if (playerGfx.ready){
    var frames, fps, idx;

    if (anim.state === "walk"){
      frames = playerGfx.walkFrames; fps = PLAYER_SPR.walk.fps;
      idx = Math.floor(anim.t * fps) % frames.length;
    } else if (anim.state === "idle"){
      frames = playerGfx.idleFrames; fps = PLAYER_SPR.idle.fps;
      idx = Math.floor(anim.t * fps) % frames.length;
    } else {
      // jump/fall: play jump strip once on takeoff, then hold last frame while airborne
      frames = playerGfx.jumpFrames; fps = PLAYER_SPR.jump.fps;
      var jumpProgress = Math.min(frames.length - 1, Math.floor(anim.t * fps));
      idx = (player.vy < 0) ? jumpProgress : (frames.length - 1); // rising anim, falling hold last
    }

    if (frames && frames.length){
      var img = frames[idx] || frames[frames.length - 1];
      var scale = PLAYER_SPR.scale || 1;
      var w = Math.round(img.width  * scale);
      var h = Math.round(img.height * scale);

      if (player.facing < 0){
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(-1, 1);
        ctx.drawImage(img, -Math.floor(w/2), -h, w, h);
        ctx.restore();
      } else {
        ctx.drawImage(img, Math.floor(x - w/2), y - h, w, h);
      }
      return;
    }
  }

  // FINAL FALLBACK: tiny pixel dude
  var wob = (player.vx!==0 ? (((anim.t*10)|0) % 2) : 0) * (player.facing>0?1:-1);
  fillRect(x-2, y-14, 6, 5, 0xf2c199); // head
  fillRect(x-3, y-9,  8, 6, 0x6332c8); // body
  fillRect(x-3+wob, y-3, 3, 3, 0x222222);
  fillRect(x+2-wob, y-3, 3, 3, 0x222222);
}

/* ---------- UI: ENTER / MODAL ---------- */
function tryEnter(){
  if(!canEnterId) return;
  var it=getById(canEnterId); if(!it) return;
  openPlaque(it);
}
function getById(id){ for(var i=0;i<ITEMS.length;i++) if(ITEMS[i].id===id) return ITEMS[i]; return null; }
function openDetails(item){
  currentOpen=item;
  modalTitle.textContent=item.title||'(Untitled)';
  modalWhen.textContent=item.when||'Today';
  modalVenue.textContent=item.venue||'';
  modalAddress.textContent=item.address||'';
  modalPhone.textContent=item.phone||'';
  modalDesc.textContent=item.description||'';

  while (modalLinks.firstChild) modalLinks.removeChild(modalLinks.firstChild);
  if(item.link){ var a=document.createElement('a'); a.className='btn'; a.href=item.link; a.target='_blank'; a.rel='noopener'; a.textContent='Open link'; modalLinks.appendChild(a); }
  if(item.address){ var g=document.createElement('a'); g.className='btn'; g.href='https://www.google.com/maps/search/?api=1&query='+encodeURIComponent(item.address); g.target='_blank'; g.rel='noopener'; g.textContent='Get directions'; modalLinks.appendChild(g); }
  if(item.phone){ var p=document.createElement('a'); p.className='btn'; p.href='tel:'+item.phone.replace(/\s+/g,''); p.textContent='Call'; modalLinks.appendChild(p); }

  modalIcs.href = makeIcs(item);
  modalBackdrop.style.display='flex';
}
function closeModal(){ modalBackdrop.style.display='none'; }

/* ---------- SAVED PANEL ---------- */
function getSaved(){ try{ return JSON.parse(localStorage.getItem('sb_saved')||'[]'); }catch(e){ return []; } }
function setSaved(arr){ localStorage.setItem('sb_saved', JSON.stringify(arr)); }
function updateSavedBadge(){ savedCountEl.textContent=String(getSaved().length); }
function saveItem(item){
  var arr=getSaved(); for(var i=0;i<arr.length;i++) if(arr[i].id===item.id){ closeModal(); return; }
  arr.push(item); setSaved(arr); updateSavedBadge(); renderSavedList(); closeModal();
}
function removeSaved(id){ var arr=getSaved().filter(function(x){return x.id!==id;}); setSaved(arr); updateSavedBadge(); renderSavedList(); }
function renderSavedList(){
  savedList.innerHTML='';
  var arr=getSaved();
  if(!arr.length){ savedList.textContent='No saved items yet.'; return; }
  for (var i=0;i<arr.length;i++){
    (function(it){
      var card=document.createElement('div'); card.className='saved-item';
      var title=document.createElement('div'); title.className='title'; title.textContent=it.title;
      var meta=document.createElement('div'); meta.className='meta'; meta.textContent=(it.when||'Today')+(it.venue?(' • '+it.venue):'');
      var row=document.createElement('div'); row.className='row';
      var det=document.createElement('button'); det.className='btn'; det.textContent='Details'; det.onclick=function(){ openDetails(it); };
      var rem=document.createElement('button'); rem.className='btn primary'; rem.textContent='Remove'; rem.onclick=function(){ removeSaved(it.id); };
      row.appendChild(det); row.appendChild(rem);
      card.appendChild(title); card.appendChild(meta); card.appendChild(row);
      savedList.appendChild(card);
    })(arr[i]);
  }
}
function toggleSavedPanel(){ setSavedPanel(!savedPanel.classList.contains('open')); }
function setSavedPanel(open){
  if(open){ renderSavedList(); savedPanel.classList.add('open'); btnSaved.setAttribute('aria-expanded','true'); savedPanel.setAttribute('aria-hidden','false'); }
  else    { savedPanel.classList.remove('open'); btnSaved.setAttribute('aria-expanded','false'); savedPanel.setAttribute('aria-hidden','true'); }
}

/* ---------- ICS ---------- */
function makeIcs(item){
  var now=new Date();
  var start=parseWhen(item.when)||new Date(now.getFullYear(),now.getMonth(),now.getDate(),19,0,0);
  var end=new Date(start.getTime()+60*60*1000);
  function p(n){return (n<10?'0':'')+n;}
  function fmt(dt){return dt.getUTCFullYear()+p(dt.getUTCMonth()+1)+p(dt.getUTCDate())+'T'+p(dt.getUTCHours())+p(dt.getUTCMinutes())+p(dt.getUTCSeconds())+'Z';}
  var lines=['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//SocialBurst//GameBoy//EN','BEGIN:VEVENT',
    'UID:'+item.id+'@socialburst','DTSTAMP:'+fmt(new Date()),'DTSTART:'+fmt(start),'DTEND:'+fmt(end),
    'SUMMARY:'+esc(item.title||''),'LOCATION:'+esc(item.venue||''),'DESCRIPTION:'+esc((item.description||'')+(item.link?(' '+item.link):'')),
    'END:VEVENT','END:VCALENDAR'];
  return URL.createObjectURL(new Blob([lines.join('\r\n')],{type:'text/calendar'}));
}
function parseWhen(str){ var m=String(str||'').toLowerCase().match(/today\s+(\d{1,2}):(\d{2})/); if(!m) return null; var h=+m[1],mi=+m[2]; var n=new Date(); return new Date(n.getFullYear(),n.getMonth(),n.getDate(),h,mi,0,0); }
function esc(s){ return String(s).replace(/([,;])/g,'\\$1').replace(/\n/g,'\\n'); }

/* ---------- LOW LEVEL DRAW ---------- */
function putPixel(x,y,hex){ ctx.fillStyle='#'+hex.toString(16).padStart(6,'0'); ctx.fillRect(x|0,y|0,1,1); }
function fillRect(x,y,w,h,hex){ ctx.fillStyle='#'+hex.toString(16).padStart(6,'0'); ctx.fillRect(x|0,y|0,w|0,h|0); }
function horizLine(x,y,len,hex){ fillRect(x,y,len,1,hex); }
function tri(x1,y1,x2,y2,x3,y3,hex){ ctx.fillStyle='#'+hex.toString(16).padStart(6,'0'); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.fill(); }
function lerpRGB(a,b,t){
  var ar=(a>>16)&255, ag=(a>>8)&255, ab=a&255;
  var br=(b>>16)&255, bg=(b>>8)&255, bb=b&255;
  var rr=(ar+(br-ar)*t)|0, gg=(ag+(bg-ag)*t)|0, bb2=(ab+(bb-ab)*t)|0;
  return (rr<<16)|(gg<<8)|bb2;
}

/* ---------- Pixel text 3x5 ---------- */
var FONT={A:["010","101","111","101","101"],B:["110","101","110","101","110"],C:["011","100","100","100","011"],D:["110","101","101","101","110"],E:["111","100","110","100","111"],F:["111","100","110","100","100"],G:["011","100","101","101","011"],H:["101","101","111","101","101"],I:["111","010","010","010","111"],J:["001","001","001","101","010"],K:["101","101","110","101","101"],L:["100","100","100","100","111"],M:["101","111","111","101","101"],N:["101","111","111","111","101"],O:["010","101","101","101","010"],P:["110","101","110","100","100"],Q:["010","101","101","111","011"],R:["110","101","110","101","101"],S:["011","100","010","001","110"],T:["111","010","010","010","010"],U:["101","101","101","101","111"],V:["101","101","101","101","010"],W:["101","101","111","111","101"],X:["101","101","010","101","101"],Y:["101","101","010","010","010"],Z:["111","001","010","100","111"]," ":[ "000","000","000","000","000" ]};
function pixelText(s,x,y,color,maxWidth){
  var px=x, w=4, chars=Math.min(Math.floor((maxWidth||1000)/w), s.length);
  s=s.toUpperCase();
  for(var i=0;i<chars;i++){
    var g=FONT[s[i]]||FONT[" "]; for(var r=0;r<5;r++){ var row=g[r]; for(var c=0;c<3;c++) if(row[c]==='1') putPixel(px+c, y+r, color); }
    px+=w;
  }
}

// --- Pixel text for the plaque (3x5 font, scaled) ---
function pixelTextScaled(ctx, s, x, y, color, scale){
  // draw using your existing 3x5 FONT; scale by whole pixels
  var w = 3, h = 5, gap = 1; // base glyph size
  var cx = x;
  s = String(s||'').toUpperCase();
  for (var i=0;i<s.length;i++){
    var g = FONT[s[i]] || FONT[" "];
    for (var r=0;r<h;r++){
      var row = g[r];
      for (var c=0;c<w;c++){
        if (row[c] === '1'){
          ctx.fillStyle = '#' + color.toString(16).padStart(6,'0');
          ctx.fillRect((cx + c*scale)|0, (y + r*scale)|0, scale, scale);
        }
      }
    }
    cx += (w + gap) * scale;
  }
  return cx;
}

function wrapPixelLines(text, maxChars){
  var words = String(text||'').split(/\s+/);
  var lines = [], cur = '';
  words.forEach(function(w){
    if ((cur + (cur? ' ':'') + w).length <= maxChars){ cur += (cur? ' ':'') + w; }
    else { if (cur) lines.push(cur); cur = w; }
  });
  if (cur) lines.push(cur);
  return lines;
}

/* ---------------- PIXEL PLAQUE RENDERING + BUTTONS ---------------- */

var plaqueHitAreas = null;   // { open:{x,y,w,h}, save:{x,y,w,h} } in canvas pixels

function pxFill(ctx, x, y, w, h, hex){
  ctx.fillStyle = '#' + hex.toString(16).padStart(6,'0');
  ctx.fillRect(x|0, y|0, w|0, h|0);
}

function drawPixelButton(ctx, x, y, w, h, label, scale){
  // frame (dark border + light face)
  pxFill(ctx, x,     y,     w,   h,   0x2b1a4f); // dark border
  pxFill(ctx, x+scale, y+scale, w-2*scale, h-2*scale, 0xf5e86b); // face

  // label centered (3x5 font scaled)
  var charW = (3+1) * scale; // 3px glyph + 1px gap
  var textW = label.length * charW - scale; // last char doesn't add gap
  var tx = Math.round(x + (w - textW)/2);
  var ty = Math.round(y + (h - 5*scale)/2);
  pixelTextScaled(ctx, label, tx, ty, 0x2b1a4f, scale);
}

/**
 * Draw all text onto the plaque canvas and return button hit areas.
 * Canvas is already sized for HiDPI by sizePlaqueCanvasForHiDPI().
 */
function drawPlaque(title, when, venue, desc){
  const ctx = plaqueCtx;
  const W = plaqueCanvas.width;
  const H = plaqueCanvas.height;

  ctx.clearRect(0, 0, W, H);

  // Scales and spacing
  const sTitle = 3;
  const sBody  = 2;
  const gapY   = 4 * sBody;   // gap between lines

  // Build the lines we’ll render
  const lines = [];
  lines.push({ text: String(title||'').toUpperCase().slice(0, 32), scale: sTitle, color: 0x301873, lineH: 7*sTitle });

  const metaColor = 0x4b2a91;
  if (when)  lines.push({ text: String(when ).toUpperCase().slice(0, 40), scale: sBody, color: metaColor, lineH: 6*sBody });
  if (venue) lines.push({ text: String(venue).toUpperCase().slice(0, 40), scale: sBody, color: metaColor, lineH: 6*sBody });

  const approxChars = Math.max(10, Math.floor(W / ((3+1)*sBody)));
  (wrapPixelLines(desc||'', approxChars).slice(0, 6)).forEach(t => {
    lines.push({ text: t.toUpperCase(), scale: sBody, color: 0x143C0D, lineH: 6*sBody });
  });

  // Measure total block height (lines + gaps)
  let blockH = 0;
  for (let i = 0; i < lines.length; i++){
    blockH += lines[i].lineH;
    if (i < lines.length - 1) blockH += gapY;
  }

  // Vertically center the whole block in the canvas (which already sits over the paper)
  let y = Math.round((H - blockH) / 2);

  // Draw each line centered horizontally
  for (let i = 0; i < lines.length; i++){
    const l = lines[i];
    const charW = (3 + 1) * l.scale;             // glyph + gap
    const textW = l.text.length * charW - l.scale; // no trailing gap on last char
    const x = Math.round((W - textW) / 2);       // <-- exact horizontal center
    pixelTextScaled(ctx, l.text, x, y, l.color, l.scale);
    y += l.lineH + (i < lines.length - 1 ? gapY : 0);
  }

  // Pixel buttons centered at bottom (inside canvas)
  const btnH   = 16 * sBody;
  const btnGap = 8  * sBody;
  const btnW   = Math.min(Math.floor((W - btnGap) / 2), Math.floor(W * 0.42));
  const by     = H - (8 * sBody) - btnH;
  const groupW = btnW*2 + btnGap;
  const b1x    = Math.round((W - groupW) / 2);
  const b2x    = b1x + btnW + btnGap;

  drawPixelButton(ctx, b1x, by, btnW, btnH, 'OPEN LINK', sBody);
  drawPixelButton(ctx, b2x, by, btnW, btnH, 'SAVE',      sBody);

  return {
    open: { x:b1x, y:by, w:btnW, h:btnH },
    save: { x:b2x, y:by, w:btnW, h:btnH }
  };
}


function drawPlaqueText(title, when, venue, desc){
  // Clear to transparent; paper sits underneath via CSS
  plaqueCtx.clearRect(0,0,plaqueCanvas.width, plaqueCanvas.height);

  // Choose a nice scale: canvas is 160x120;  scale=2 makes chunky pixels
  var scaleTitle = 3;
  var scaleBody  = 2;

  var x = 6, y = 8;

  // Title (truncate to fit ~22 chars at scale 3)
  var titleLine = String(title||'').toUpperCase().slice(0, 22);
  pixelTextScaled(plaqueCtx, titleLine, x, y, 0x301873, scaleTitle);
  y += 7 * scaleTitle; // title spacing

  // Meta lines
  var metaColor = 0x4b2a91;
  var meta1 = (when||'Today').toUpperCase();
  var meta2 = (venue||'').toUpperCase();

  pixelTextScaled(plaqueCtx, meta1.slice(0, 26), x, y, metaColor, scaleBody);
  y += 7 * scaleBody;
  if (meta2){
    pixelTextScaled(plaqueCtx, meta2.slice(0, 26), x, y, metaColor, scaleBody);
    y += 7 * scaleBody;
  }

  // Description wrapped (≈ 28 chars/line at scale 2)
  var lines = wrapPixelLines(desc||'', 28);
  for (var i=0;i<Math.min(lines.length, 5); i++){
    pixelTextScaled(plaqueCtx, lines[i].toUpperCase(), x, y, 0x143C0D, scaleBody);
    y += 6 * scaleBody;
  }
}
// --- helper to make the plaque canvas crisp on retina / hi-DPI screens ---
function sizePlaqueCanvasForHiDPI() {
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const box = plaqueCanvas.getBoundingClientRect();
  const w = Math.floor(box.width * dpr);
  const h = Math.floor(box.height * dpr);
  plaqueCanvas.width  = w;
  plaqueCanvas.height = h;
  plaqueCtx.imageSmoothingEnabled = false;
}

function openPlaque(item){
  // keep the data accessible for button handlers
  currentOpen = item;

  // 1) show FIRST so the element has a real size
  plaque.classList.add('show');
  plaque.style.display = 'flex';
  UI_LOCK = true;

  // 2) next frame: measure, scale for HiDPI, and draw the text/buttons
  requestAnimationFrame(function(){
    sizePlaqueCanvasForHiDPI();
    plaqueHitAreas = drawPlaque(
      item.title,
      item.when,
      item.venue,
      item.description
    );
  });
}

function closePlaque(){
  plaque.classList.remove('show');
  plaque.style.display = 'none';
  UI_LOCK = false;
}

plaqueClose.addEventListener('click', closePlaque);
plaque.addEventListener('click', function(e){
  if (e.target === plaque) closePlaque(); // click outside to close
});
// === Pixel button hit-testing on the plaque canvas ===
function pointIn(r, x, y){
  return x >= r.x && y >= r.y && x <= r.x + r.w && y <= r.y + r.h;
}

plaqueCanvas.addEventListener('click', function(e){
  if (!plaqueHitAreas) return;

  const rect = plaqueCanvas.getBoundingClientRect();
  const dpr  = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top)  * dpr;

  if (pointIn(plaqueHitAreas.open, x, y)){
    if (currentOpen && currentOpen.link){
      window.open(currentOpen.link, '_blank', 'noopener');
    }
    return;
  }

  if (pointIn(plaqueHitAreas.save, x, y)){
    if (currentOpen) saveItem(currentOpen);
    return;
  }
});
// Keep the pixels crisp if the window resizes while plaque is open
window.addEventListener('resize', function(){
  if (plaque.classList.contains('show') && currentOpen){
    sizePlaqueCanvasForHiDPI();
    plaqueHitAreas = drawPlaque(currentOpen.title, currentOpen.when, currentOpen.venue, currentOpen.description);
  }
});
/* ---------- UTILS ---------- */
function hashId(s){ var h=0; for(var i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return 'sb_'+Math.abs(h); }



</script>
</body>
</html>
